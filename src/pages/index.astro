---
// Main comparison table page
import '../styles/global.css';
import { z } from 'zod';
import type { Agent, FeatureStatus } from '../agents/featureSetSchema';
import { featuresRegistry, featureSetSchema } from '../agents/featureSetSchema';
import { allAgents } from '../agents/allAgents';

// Load all agents from allAgents.ts
const agents: Agent[] = allAgents;

// Extract display names from registry
function formatDisplayName(key: string): string {
  return key
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Build category display names from registry
const categoryDisplayNames: Record<string, string> = {};
const featureDisplayNames: Record<string, string> = {};

// Extract category names from featureSetSchema
const categoryOrder: (keyof Agent['features'])[] = ['planning', 'reasoning', 'tests'];
for (const categoryKey of categoryOrder) {
  const categorySchema = featureSetSchema.shape[categoryKey];
  const categoryMeta = featuresRegistry.get(categorySchema);
  if (!categoryMeta) {
    throw new Error(`Category ${categoryKey} not found in featuresRegistry`);
  }
  categoryDisplayNames[categoryKey] = categoryMeta.name 
    ? formatDisplayName(categoryMeta.name) 
    : formatDisplayName(categoryKey);
  
  // Extract feature names from each category
  if (categorySchema instanceof z.ZodObject) {
    const featureKeys = Object.keys(categorySchema.shape);
    for (const featureKey of featureKeys) {
      const featureSchema = categorySchema.shape[featureKey];
      const featureMeta = featuresRegistry.get(featureSchema);
      featureDisplayNames[featureKey] = featureMeta?.name 
        ? formatDisplayName(featureMeta.name) 
        : formatDisplayName(featureKey);
    }
  }
}

// Define feature order
const featureOrder: Record<string, string[]> = {
  planning: ['multi-step-planning', 'plan-editing', 'plan-execution'],
  reasoning: ['explanation-in-natural-language', 'step-by-step-view'],
  tests: ['test-generation', 'integrates-with-ci', 'editor-plugins-available'],
};

// Helper function to get status symbol
function getStatusSymbol(status: FeatureStatus | string): string {
  const statusStr = String(status);
  switch (statusStr) {
    case 'supported':
      return '✓';
    case 'partially-supported':
      return '◐';
    case 'not-supported':
      return '✗';
    default:
      return '';
  }
}

// Helper function to get status class
function getStatusClass(status: FeatureStatus | string): string {
  const statusStr = String(status);
  switch (statusStr) {
    case 'supported':
      return 'supported';
    case 'partially-supported':
      return 'partially-supported';
    case 'not-supported':
      return 'not-supported';
    default:
      return '';
  }
}
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Compare coding agents based on their features and capabilities" />
    <title>Compare coding agents</title>
  </head>
  <body>
    <main>
      <h1>Compare coding agents</h1>
      <p class="subtitle">Compare coding agents based on their features and capabilities</p>
      
      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th></th>
              {agents.map((agent) => (
                <th>{agent.meta.name}</th>
              ))}
            </tr>
          </thead>
          <tbody>
            {categoryOrder.flatMap((categoryKey) => {
              const category = categoryKey as keyof Agent['features'];
              const features = featureOrder[category];
              return [
                <tr class="category-header">
                  <td colspan={agents.length + 1}>{categoryDisplayNames[category]}</td>
                </tr>,
                ...features.map((featureKey) => (
                  <tr key={featureKey}>
                    <td>{featureDisplayNames[featureKey]}</td>
                    {agents.map((agent) => {
                      const status = agent.features[category][featureKey as keyof typeof agent.features[typeof category]];
                      return (
                        <td key={agent.meta.id}>
                          <span class={`symbol ${getStatusClass(status)}`}>
                            {getStatusSymbol(status)}
                          </span>
                        </td>
                      );
                    })}
                  </tr>
                ))
              ];
            })}
          </tbody>
        </table>
      </div>
      
      <div class="legend">
        <p><strong>Legend:</strong></p>
        <ul>
          <li><span class="symbol supported">✓</span> Fully supported</li>
          <li><span class="symbol partially-supported">◐</span> Partially supported</li>
          <li><span class="symbol not-supported">✗</span> Not supported</li>
        </ul>
      </div>
    </main>
  </body>
</html>

